package com.two.serviceusers.users;

import com.two.http_api.model.Tokens;
import com.two.http_api.model.User;
import com.two.http_api.model.UserWithCredentials;
import com.two.serviceusers.authentication.AuthenticationDao;
import dev.testbed.TestBed;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.http.HttpStatus;
import org.springframework.web.server.ResponseStatusException;

import java.util.Optional;

import static com.two.http_api.model.PublicApiModel.UserRegistration;
import static java.util.Optional.empty;
import static java.util.Optional.of;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

class UserServiceTest {

    private TestBuilder tb;

    @BeforeEach
    void setup() {
        this.tb = new TestBuilder();
    }

    @Nested
    class StoreUser {
        private UserRegistration userRegistration = new UserRegistration(
                "two@two.com", "test-password", "Two", "TwoL", true, true
        );

        private User user = User.builder().uid(99).pid(null).cid(null).firstName("Two").lastName("TwoL").build();

        @Test
        @DisplayName("it should store the user via the DAO")
        void storesUser() {
            tb.whenStoreUserReturn(user).build().storeUser(userRegistration);

            verify(tb.getDependency(UserDao.class)).storeUser(userRegistration);
        }

        @Test
        @DisplayName("it should store the user credentials via the DAO")
        void storesCredentials() {
            tb.whenStoreUserReturn(user).build().storeUser(userRegistration);

            UserWithCredentials userWithCredentials = UserWithCredentials.fromUser(
                    user, userRegistration.getEmail(), userRegistration.getPassword()
            );

            verify(tb.getDependency(AuthenticationDao.class)).storeCredentials(userWithCredentials);
        }

        @Test
        @DisplayName("it should return the tokens generated by the DAO")
        void returnsTokens() {
            Tokens tokens = new Tokens("refresh-token", "access-token");
            UserService userService = tb.whenStoreUserReturn(user).whenStoreCredentialsReturn(tokens).build();

            Tokens generatedTokens = userService.storeUser(userRegistration);

            assertThat(generatedTokens).isEqualTo(tokens);
        }

        @Test
        @DisplayName("it should throw a Bad Requset Exception if the DAO raises a DuplicateKeyException")
        void throwsBadRequestException() {
            UserService userService = tb.whenStoreUserThrowDuplicateKeyException().build();

            assertThatThrownBy(() -> userService.storeUser(userRegistration))
                    .isInstanceOf(ResponseStatusException.class)
                    .hasMessageContaining("This user already exists.")
                    .hasFieldOrPropertyWithValue("status", HttpStatus.BAD_REQUEST);
        }
    }

    @Nested
    class LoginUser {
        User user = User.builder().uid(12).pid(13).cid(14).firstName("Two").lastName("TwoL").build();

        @Test
        @DisplayName("it should retrieve the user")
        void retrievesUser() {
            UserService userService = tb.whenGetUserReturn(of(user)).build();

            userService.loginUser("gerry@two.com", "rawPassword");

            verify(tb.getDependency(UserDao.class)).getUser("gerry@two.com", User.class);
        }

        @Test
        @DisplayName("it should throw a Bad Request Response Status Exception if the user does not exist")
        void throwsBadRequestResponseStatusException() {
            UserService userService = tb.whenGetUserReturn(empty()).build();

            assertThatThrownBy(() -> userService.loginUser("gerry@two.com", "rawPassword"))
                    .isInstanceOf(ResponseStatusException.class)
                    .hasMessageContaining("This user does not exist.")
                    .hasFieldOrPropertyWithValue("status", HttpStatus.NOT_FOUND);
        }

        @Test
        @DisplayName("it should authenticate with the UID and raw password")
        void authenticates() {
            UserService userService = tb.whenGetUserReturn(of(user)).build();

            userService.loginUser("two@two.com", "rawPassword");

            verify(tb.getDependency(AuthenticationDao.class)).authenticateAndCreateTokens(
                    UserWithCredentials.fromUser(user, "two@two.com", "rawPassword")
            );
        }

        @Test
        @DisplayName("it should return the generated tokens on a successful request")
        void returnsTokens() {
            Tokens tokens = new Tokens("refresh", "access");
            UserService userService = tb.whenGetUserReturn(of(user))
                    .whenAuthenticateAndCreateTokensReturn(tokens)
                    .build();

            Tokens createdTokens = userService.loginUser("gerry@two.com", "rawPassword");

            assertThat(createdTokens).isEqualTo(tokens);
        }
    }

    @Nested
    class GetUser {
        User user = User.builder().uid(12).pid(13).cid(14).firstName("Two").lastName("TwoL").build();

        @Test
        @DisplayName("it should retrieve the user from the DAO")
        void retrievesUser() {
            UserService userService = tb.whenGetUserReturn(of(user)).build();

            User retrievedUser = userService.getUser(12, User.class);

            verify(tb.getDependency(UserDao.class)).getUser(12, User.class);
            assertThat(retrievedUser).isEqualTo(user);
        }

        @Test
        @DisplayName("it should throw UserNotFoundException if the user does not exist.")
        void userNotFound() {
            UserService userService = tb.whenGetUserReturn(empty()).build();

            assertThatThrownBy(() -> userService.getUser(12, User.class))
                    .isInstanceOf(UserNotExistsException.class);
        }
    }

    static class TestBuilder extends TestBed<UserService, TestBuilder> {
        TestBuilder() {
            super(UserService.class);
        }

        TestBuilder whenStoreUserReturn(User user) {
            when(getDependency(UserDao.class).storeUser(any(UserRegistration.class))).thenReturn(user);
            return this;
        }

        TestBuilder whenStoreUserThrowDuplicateKeyException() {
            when(getDependency(UserDao.class).storeUser(any(UserRegistration.class)))
                    .thenThrow(DuplicateKeyException.class);
            return this;
        }

        TestBuilder whenStoreCredentialsReturn(Tokens tokens) {
            when(getDependency(AuthenticationDao.class).storeCredentials(any(UserWithCredentials.class))).thenReturn(tokens);
            return this;
        }

        TestBuilder whenGetUserReturn(Optional<User> userOptional) {
            when(getDependency(UserDao.class).getUser(anyString(), any())).thenReturn(userOptional);
            when(getDependency(UserDao.class).getUser(anyInt(), eq(User.class))).thenReturn(userOptional);
            return this;
        }

        TestBuilder whenAuthenticateAndCreateTokensReturn(Tokens tokens) {
            when(getDependency(AuthenticationDao.class).authenticateAndCreateTokens(any(UserWithCredentials.class)))
                    .thenReturn(tokens);
            return this;
        }
    }
}